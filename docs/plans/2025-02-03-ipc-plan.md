# Phase 2: IPC Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add gRPC-based communication between daemon and CLI with daemon process management.

**Architecture:** Proto crate defines service, daemon runs tonic gRPC server on Unix socket, CLI connects as client. Controller manages engine lifecycle and broadcasts events to subscribers.

**Tech Stack:** tonic, prost, tokio, tokio-stream

---

## Task 1: Create Proto Crate

**Files:**
- Create: `proto/Cargo.toml`
- Create: `proto/build.rs`
- Create: `proto/src/lib.rs`
- Create: `proto/src/voice_controllm.proto`
- Modify: `Cargo.toml` (workspace members)

**Step 1: Create proto crate directory**

```bash
mkdir -p proto/src
```

**Step 2: Create Cargo.toml**

Create `proto/Cargo.toml`:

```toml
[package]
name = "voice-controllm-proto"
version.workspace = true
edition.workspace = true
license.workspace = true
repository.workspace = true

[dependencies]
prost = "0.13"
tonic = "0.12"

[build-dependencies]
tonic-build = "0.12"
```

**Step 3: Create build.rs**

Create `proto/build.rs`:

```rust
fn main() -> Result<(), Box<dyn std::error::Error>> {
    tonic_build::configure()
        .build_server(true)
        .build_client(true)
        .compile_protos(&["src/voice_controllm.proto"], &["src/"])?;
    Ok(())
}
```

**Step 4: Create the proto file**

Create `proto/src/voice_controllm.proto`:

```protobuf
syntax = "proto3";
package voice_controllm;

service VoiceControllm {
  // Control
  rpc StartListening(Empty) returns (Empty);
  rpc StopListening(Empty) returns (Empty);
  rpc Shutdown(Empty) returns (Empty);

  // Query
  rpc GetStatus(Empty) returns (Status);

  // Streaming
  rpc Subscribe(Empty) returns (stream Event);
}

message Empty {}

message Status {
  oneof status {
    Healthy healthy = 1;
    Error error = 2;
  }
}

message Healthy {
  State state = 1;
}

enum State {
  STATE_STOPPED = 0;
  STATE_LISTENING = 1;
  STATE_PAUSED = 2;
}

message Error {
  string message = 1;
}

message Event {
  oneof event {
    StateChange state_change = 1;
    Transcription transcription = 2;
  }
}

message StateChange {
  oneof status {
    State new_state = 1;
    Error error = 2;
  }
}

message Transcription {
  string text = 1;
  double confidence = 2;
}
```

**Step 5: Create lib.rs**

Create `proto/src/lib.rs`:

```rust
pub mod voice_controllm {
    tonic::include_proto!("voice_controllm");
}

pub use voice_controllm::*;
```

**Step 6: Add proto to workspace**

Modify `Cargo.toml` (workspace root):

```toml
[workspace]
resolver = "2"
members = ["daemon", "cli", "proto"]

[workspace.package]
version = "0.1.0"
edition = "2024"
license = "MIT"
repository = "https://github.com/palicand/voice-controllm"
```

**Step 7: Build to verify codegen**

Run: `cargo build -p voice-controllm-proto`

Expected: Build succeeds, generated code in `target/`

**Step 8: Commit**

```bash
git add proto/ Cargo.toml
git commit -m "feat(proto): add gRPC service definitions"
```

---

## Task 2: Add Daemon gRPC Server (Stub)

**Files:**
- Modify: `daemon/Cargo.toml`
- Create: `daemon/src/server.rs`
- Modify: `daemon/src/lib.rs`

**Step 1: Add dependencies to daemon**

Run:
```bash
cargo add -p voice-controllm-daemon tonic@0.12
cargo add -p voice-controllm-daemon tokio-stream@0.1 --features sync
cargo add -p voice-controllm-daemon voice-controllm-proto --path proto
```

**Step 2: Create server module with stub implementation**

Create `daemon/src/server.rs`:

```rust
//! gRPC server for daemon control.

use std::pin::Pin;
use tokio::sync::broadcast;
use tokio_stream::wrappers::BroadcastStream;
use tokio_stream::Stream;
use tonic::{Request, Response, Status};
use voice_controllm_proto::{
    voice_controllm_server::{VoiceControllm, VoiceControllmServer},
    Empty, Event, Healthy, State,
};

/// Event sender for broadcasting to subscribers.
pub type EventSender = broadcast::Sender<Event>;

/// gRPC service implementation.
pub struct VoiceControllmService {
    event_tx: EventSender,
}

impl VoiceControllmService {
    /// Create a new service with the given event sender.
    pub fn new(event_tx: EventSender) -> Self {
        Self { event_tx }
    }

    /// Create the tonic server.
    pub fn into_server(self) -> VoiceControllmServer<Self> {
        VoiceControllmServer::new(self)
    }
}

#[tonic::async_trait]
impl VoiceControllm for VoiceControllmService {
    async fn start_listening(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        // Stub: will be wired to controller in Task 3
        Ok(Response::new(Empty {}))
    }

    async fn stop_listening(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        // Stub: will be wired to controller in Task 3
        Ok(Response::new(Empty {}))
    }

    async fn shutdown(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        // Stub: will be wired to controller in Task 3
        Ok(Response::new(Empty {}))
    }

    async fn get_status(
        &self,
        _request: Request<Empty>,
    ) -> Result<Response<voice_controllm_proto::Status>, Status> {
        // Stub: return paused state
        let status = voice_controllm_proto::Status {
            status: Some(voice_controllm_proto::status::Status::Healthy(Healthy {
                state: State::StatePaused.into(),
            })),
        };
        Ok(Response::new(status))
    }

    type SubscribeStream = Pin<Box<dyn Stream<Item = Result<Event, Status>> + Send>>;

    async fn subscribe(
        &self,
        _request: Request<Empty>,
    ) -> Result<Response<Self::SubscribeStream>, Status> {
        let rx = self.event_tx.subscribe();
        let stream = BroadcastStream::new(rx).map(|result| {
            result.map_err(|e| Status::internal(format!("Broadcast error: {}", e)))
        });
        Ok(Response::new(Box::pin(stream)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_service_creation() {
        let (tx, _rx) = broadcast::channel(16);
        let _service = VoiceControllmService::new(tx);
    }
}
```

**Step 3: Fix the import - add StreamExt**

The code needs `StreamExt` for `.map()`. Update imports at the top of `daemon/src/server.rs`:

```rust
use tokio_stream::StreamExt;
```

Add this after the existing `use tokio_stream::Stream;` line.

**Step 4: Add server module to lib.rs**

Modify `daemon/src/lib.rs`:

```rust
pub mod audio;
pub mod config;
pub mod engine;
pub mod inject;
pub mod models;
pub mod server;
pub mod transcribe;
pub mod vad;
```

**Step 5: Build to verify**

Run: `cargo build -p voice-controllm-daemon`

Expected: Build succeeds

**Step 6: Run tests**

Run: `cargo test -p voice-controllm-daemon server`

Expected: `test_service_creation` passes

**Step 7: Commit**

```bash
git add daemon/
git commit -m "feat(daemon): add gRPC server stub"
```

---

## Task 3: Add Controller with State Machine

**Files:**
- Create: `daemon/src/controller.rs`
- Modify: `daemon/src/lib.rs`
- Modify: `daemon/src/server.rs`

**Step 1: Write failing test for controller state transitions**

Create `daemon/src/controller.rs`:

```rust
//! Controller manages daemon state and coordinates components.

use std::sync::Arc;
use tokio::sync::{broadcast, RwLock};
use voice_controllm_proto::{Event, State, StateChange};

/// Controller state.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ControllerState {
    Stopped,
    Listening,
    Paused,
}

impl From<ControllerState> for State {
    fn from(state: ControllerState) -> Self {
        match state {
            ControllerState::Stopped => State::StateStopped,
            ControllerState::Listening => State::StateListening,
            ControllerState::Paused => State::StatePaused,
        }
    }
}

/// Event sender type.
pub type EventSender = broadcast::Sender<Event>;

/// Controller for daemon state management.
pub struct Controller {
    state: Arc<RwLock<ControllerState>>,
    event_tx: EventSender,
}

impl Controller {
    /// Create a new controller.
    pub fn new(event_tx: EventSender) -> Self {
        Self {
            state: Arc::new(RwLock::new(ControllerState::Paused)),
            event_tx,
        }
    }

    /// Get the current state.
    pub async fn state(&self) -> ControllerState {
        *self.state.read().await
    }

    /// Start listening.
    pub async fn start_listening(&self) -> Result<(), String> {
        let mut state = self.state.write().await;
        match *state {
            ControllerState::Paused => {
                *state = ControllerState::Listening;
                self.broadcast_state_change(ControllerState::Listening);
                Ok(())
            }
            ControllerState::Listening => Ok(()), // Already listening
            ControllerState::Stopped => Err("Daemon is stopped".to_string()),
        }
    }

    /// Stop listening (pause).
    pub async fn stop_listening(&self) -> Result<(), String> {
        let mut state = self.state.write().await;
        match *state {
            ControllerState::Listening => {
                *state = ControllerState::Paused;
                self.broadcast_state_change(ControllerState::Paused);
                Ok(())
            }
            ControllerState::Paused => Ok(()), // Already paused
            ControllerState::Stopped => Err("Daemon is stopped".to_string()),
        }
    }

    /// Broadcast a state change event.
    fn broadcast_state_change(&self, new_state: ControllerState) {
        let event = Event {
            event: Some(voice_controllm_proto::event::Event::StateChange(
                StateChange {
                    status: Some(voice_controllm_proto::state_change::Status::NewState(
                        State::from(new_state).into(),
                    )),
                },
            )),
        };
        // Ignore send errors (no subscribers)
        let _ = self.event_tx.send(event);
    }

    /// Get the event sender for creating subscribers.
    pub fn event_sender(&self) -> EventSender {
        self.event_tx.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_initial_state_is_paused() {
        let (tx, _rx) = broadcast::channel(16);
        let controller = Controller::new(tx);
        assert_eq!(controller.state().await, ControllerState::Paused);
    }

    #[tokio::test]
    async fn test_start_listening_from_paused() {
        let (tx, _rx) = broadcast::channel(16);
        let controller = Controller::new(tx);

        controller.start_listening().await.unwrap();
        assert_eq!(controller.state().await, ControllerState::Listening);
    }

    #[tokio::test]
    async fn test_stop_listening_from_listening() {
        let (tx, _rx) = broadcast::channel(16);
        let controller = Controller::new(tx);

        controller.start_listening().await.unwrap();
        controller.stop_listening().await.unwrap();
        assert_eq!(controller.state().await, ControllerState::Paused);
    }

    #[tokio::test]
    async fn test_start_listening_broadcasts_event() {
        let (tx, mut rx) = broadcast::channel(16);
        let controller = Controller::new(tx);

        controller.start_listening().await.unwrap();

        let event = rx.recv().await.unwrap();
        match event.event {
            Some(voice_controllm_proto::event::Event::StateChange(change)) => {
                match change.status {
                    Some(voice_controllm_proto::state_change::Status::NewState(state)) => {
                        assert_eq!(state, State::StateListening.into());
                    }
                    _ => panic!("Expected NewState"),
                }
            }
            _ => panic!("Expected StateChange event"),
        }
    }
}
```

**Step 2: Add controller module to lib.rs**

Modify `daemon/src/lib.rs`:

```rust
pub mod audio;
pub mod config;
pub mod controller;
pub mod engine;
pub mod inject;
pub mod models;
pub mod server;
pub mod transcribe;
pub mod vad;
```

**Step 3: Run tests to verify**

Run: `cargo test -p voice-controllm-daemon controller`

Expected: All 4 tests pass

**Step 4: Wire controller to server**

Modify `daemon/src/server.rs` to use controller:

```rust
//! gRPC server for daemon control.

use std::pin::Pin;
use std::sync::Arc;
use tokio::sync::broadcast;
use tokio_stream::wrappers::BroadcastStream;
use tokio_stream::{Stream, StreamExt};
use tonic::{Request, Response, Status};
use voice_controllm_proto::{
    voice_controllm_server::{VoiceControllm, VoiceControllmServer},
    Empty, Event, Healthy, State,
};

use crate::controller::{Controller, ControllerState};

/// gRPC service implementation.
pub struct VoiceControllmService {
    controller: Arc<Controller>,
}

impl VoiceControllmService {
    /// Create a new service with the given controller.
    pub fn new(controller: Arc<Controller>) -> Self {
        Self { controller }
    }

    /// Create the tonic server.
    pub fn into_server(self) -> VoiceControllmServer<Self> {
        VoiceControllmServer::new(self)
    }
}

#[tonic::async_trait]
impl VoiceControllm for VoiceControllmService {
    async fn start_listening(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        self.controller
            .start_listening()
            .await
            .map_err(|e| Status::failed_precondition(e))?;
        Ok(Response::new(Empty {}))
    }

    async fn stop_listening(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        self.controller
            .stop_listening()
            .await
            .map_err(|e| Status::failed_precondition(e))?;
        Ok(Response::new(Empty {}))
    }

    async fn shutdown(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        // Will be implemented in Task 6
        Ok(Response::new(Empty {}))
    }

    async fn get_status(
        &self,
        _request: Request<Empty>,
    ) -> Result<Response<voice_controllm_proto::Status>, Status> {
        let state = self.controller.state().await;
        let proto_state = match state {
            ControllerState::Stopped => State::StateStopped,
            ControllerState::Listening => State::StateListening,
            ControllerState::Paused => State::StatePaused,
        };
        let status = voice_controllm_proto::Status {
            status: Some(voice_controllm_proto::status::Status::Healthy(Healthy {
                state: proto_state.into(),
            })),
        };
        Ok(Response::new(status))
    }

    type SubscribeStream = Pin<Box<dyn Stream<Item = Result<Event, Status>> + Send>>;

    async fn subscribe(
        &self,
        _request: Request<Empty>,
    ) -> Result<Response<Self::SubscribeStream>, Status> {
        let rx = self.controller.event_sender().subscribe();
        let stream = BroadcastStream::new(rx).map(|result| {
            result.map_err(|e| Status::internal(format!("Broadcast error: {}", e)))
        });
        Ok(Response::new(Box::pin(stream)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_service_creation() {
        let (tx, _rx) = broadcast::channel(16);
        let controller = Arc::new(Controller::new(tx));
        let _service = VoiceControllmService::new(controller);
    }
}
```

**Step 5: Build and test**

Run: `cargo test -p voice-controllm-daemon`

Expected: All tests pass

**Step 6: Commit**

```bash
git add daemon/src/controller.rs daemon/src/server.rs daemon/src/lib.rs
git commit -m "feat(daemon): add controller with state machine"
```

---

## Task 4: Add Unix Socket Server

**Files:**
- Create: `daemon/src/socket.rs`
- Modify: `daemon/src/lib.rs`

**Step 1: Add hyper dependency for Unix socket support**

Run:
```bash
cargo add -p voice-controllm-daemon hyper@1.6 --features server
cargo add -p voice-controllm-daemon hyper-util@0.1 --features tokio
cargo add -p voice-controllm-daemon tower@0.5
```

**Step 2: Create socket module**

Create `daemon/src/socket.rs`:

```rust
//! Unix socket utilities for daemon communication.

use std::path::{Path, PathBuf};
use anyhow::{Context, Result};
use tokio::net::UnixListener;
use xdg::BaseDirectories;

/// Get the daemon socket path.
pub fn socket_path() -> Result<PathBuf> {
    let xdg = BaseDirectories::with_prefix("voice-controllm")
        .context("Failed to get XDG directories")?;
    let state_dir = xdg
        .get_state_home();
    std::fs::create_dir_all(&state_dir)
        .context("Failed to create state directory")?;
    Ok(state_dir.join("daemon.sock"))
}

/// Get the daemon PID file path.
pub fn pid_path() -> Result<PathBuf> {
    let xdg = BaseDirectories::with_prefix("voice-controllm")
        .context("Failed to get XDG directories")?;
    let state_dir = xdg.get_state_home();
    std::fs::create_dir_all(&state_dir)
        .context("Failed to create state directory")?;
    Ok(state_dir.join("daemon.pid"))
}

/// Create a Unix listener, removing stale socket if present.
pub fn create_listener(path: &Path) -> Result<UnixListener> {
    // Remove existing socket if present
    if path.exists() {
        std::fs::remove_file(path)
            .context("Failed to remove existing socket")?;
    }

    UnixListener::bind(path)
        .context("Failed to bind Unix socket")
}

/// Remove the socket file.
pub fn cleanup_socket(path: &Path) {
    let _ = std::fs::remove_file(path);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_socket_path_in_xdg_state() {
        let path = socket_path().unwrap();
        assert!(path.to_string_lossy().contains("voice-controllm"));
        assert!(path.to_string_lossy().ends_with("daemon.sock"));
    }

    #[test]
    fn test_pid_path_in_xdg_state() {
        let path = pid_path().unwrap();
        assert!(path.to_string_lossy().contains("voice-controllm"));
        assert!(path.to_string_lossy().ends_with("daemon.pid"));
    }

    #[tokio::test]
    async fn test_create_listener() {
        let temp = tempfile::tempdir().unwrap();
        let sock_path = temp.path().join("test.sock");

        let listener = create_listener(&sock_path).unwrap();
        assert!(sock_path.exists());

        drop(listener);
        cleanup_socket(&sock_path);
        assert!(!sock_path.exists());
    }
}
```

**Step 3: Add socket module to lib.rs**

Modify `daemon/src/lib.rs`:

```rust
pub mod audio;
pub mod config;
pub mod controller;
pub mod engine;
pub mod inject;
pub mod models;
pub mod server;
pub mod socket;
pub mod transcribe;
pub mod vad;
```

**Step 4: Run tests**

Run: `cargo test -p voice-controllm-daemon socket`

Expected: All 3 tests pass

**Step 5: Commit**

```bash
git add daemon/src/socket.rs daemon/src/lib.rs
git commit -m "feat(daemon): add Unix socket utilities"
```

---

## Task 5: Create Daemon Runner

**Files:**
- Create: `daemon/src/daemon.rs`
- Modify: `daemon/src/lib.rs`
- Modify: `daemon/src/main.rs`

**Step 1: Create daemon runner module**

Create `daemon/src/daemon.rs`:

```rust
//! Daemon runner that orchestrates all components.

use std::sync::Arc;
use anyhow::{Context, Result};
use tokio::sync::broadcast;
use tonic::transport::Server;
use tower::ServiceBuilder;
use tracing::info;

use crate::controller::Controller;
use crate::server::VoiceControllmService;
use crate::socket::{cleanup_socket, create_listener, pid_path, socket_path};

/// Run the daemon.
pub async fn run() -> Result<()> {
    // Get paths
    let sock_path = socket_path()?;
    let pid_file = pid_path()?;

    // Write PID file
    let pid = std::process::id();
    std::fs::write(&pid_file, pid.to_string())
        .context("Failed to write PID file")?;
    info!(pid = pid, path = %pid_file.display(), "Wrote PID file");

    // Create Unix socket listener
    let listener = create_listener(&sock_path)?;
    info!(path = %sock_path.display(), "Listening on Unix socket");

    // Create controller with event channel
    let (event_tx, _) = broadcast::channel(256);
    let controller = Arc::new(Controller::new(event_tx));

    // Create gRPC service
    let service = VoiceControllmService::new(controller.clone());

    // Convert UnixListener to stream
    let incoming = async_stream::stream! {
        loop {
            match listener.accept().await {
                Ok((stream, _)) => yield Ok::<_, std::io::Error>(stream),
                Err(e) => {
                    tracing::error!(error = %e, "Accept error");
                }
            }
        }
    };

    // Run server
    info!("Daemon started");
    let result = Server::builder()
        .add_service(service.into_server())
        .serve_with_incoming(incoming)
        .await;

    // Cleanup
    cleanup_socket(&sock_path);
    let _ = std::fs::remove_file(&pid_file);
    info!("Daemon stopped");

    result.context("Server error")
}
```

**Step 2: Add async-stream dependency**

Run:
```bash
cargo add -p voice-controllm-daemon async-stream@0.3
```

**Step 3: Add daemon module to lib.rs**

Modify `daemon/src/lib.rs`:

```rust
pub mod audio;
pub mod config;
pub mod controller;
pub mod daemon;
pub mod engine;
pub mod inject;
pub mod models;
pub mod server;
pub mod socket;
pub mod transcribe;
pub mod vad;
```

**Step 4: Update daemon main.rs**

Modify `daemon/src/main.rs`:

```rust
use tracing_subscriber::{EnvFilter, fmt, prelude::*};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::registry()
        .with(fmt::layer())
        .with(EnvFilter::from_default_env())
        .init();

    voice_controllm_daemon::daemon::run().await
}
```

**Step 5: Build to verify**

Run: `cargo build -p voice-controllm-daemon`

Expected: Build succeeds

**Step 6: Commit**

```bash
git add daemon/
git commit -m "feat(daemon): add daemon runner with Unix socket server"
```

---

## Task 6: Add CLI gRPC Client

**Files:**
- Modify: `cli/Cargo.toml`
- Create: `cli/src/client.rs`
- Modify: `cli/src/main.rs`

**Step 1: Add dependencies to CLI**

Run:
```bash
cargo add -p vcm tonic@0.12
cargo add -p vcm tower@0.5
cargo add -p vcm hyper-util@0.1 --features tokio
cargo add -p vcm voice-controllm-proto --path proto
```

**Step 2: Create client module**

Create `cli/src/client.rs`:

```rust
//! gRPC client for communicating with daemon.

use std::path::Path;
use anyhow::{Context, Result};
use tokio::net::UnixStream;
use tonic::transport::{Channel, Endpoint, Uri};
use tower::service_fn;
use voice_controllm_proto::voice_controllm_client::VoiceControllmClient;

/// Connect to daemon via Unix socket.
pub async fn connect(socket_path: &Path) -> Result<VoiceControllmClient<Channel>> {
    let socket_path = socket_path.to_path_buf();

    // Create channel with Unix socket connector
    let channel = Endpoint::try_from("http://[::]:50051")?
        .connect_with_connector(service_fn(move |_: Uri| {
            let path = socket_path.clone();
            async move {
                UnixStream::connect(path).await
            }
        }))
        .await
        .context("Failed to connect to daemon")?;

    Ok(VoiceControllmClient::new(channel))
}

/// Check if daemon is running by attempting to connect.
pub async fn is_daemon_running(socket_path: &Path) -> bool {
    if !socket_path.exists() {
        return false;
    }
    connect(socket_path).await.is_ok()
}
```

**Step 3: Update CLI main.rs with status command**

Modify `cli/src/main.rs`:

```rust
mod client;

use anyhow::{Context, Result};
use clap::{Parser, Subcommand, ValueEnum};
use tracing_subscriber::{EnvFilter, fmt, prelude::*};
use voice_controllm_daemon::config::{Config, SpeechModel};
use voice_controllm_daemon::socket::socket_path;
use voice_controllm_proto::{Empty, status::Status as StatusVariant};

#[derive(Parser)]
#[command(name = "vcm")]
#[command(about = "Voice-Controllm CLI - offline voice dictation")]
#[command(version)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Start the voice dictation daemon
    Start,
    /// Stop the voice dictation daemon
    Stop,
    /// Show daemon status
    Status,
    /// Toggle listening on/off
    Toggle,
    /// Manage configuration
    Config {
        #[command(subcommand)]
        action: ConfigAction,
    },
}

#[derive(Subcommand)]
enum ConfigAction {
    /// Show configuration file path
    Path,
    /// Create default configuration file
    Init {
        /// Speech model to use
        #[arg(long, short, value_enum, default_value = "whisper-base")]
        model: ModelArg,
        /// Overwrite existing config file
        #[arg(long)]
        force: bool,
    },
    /// Show current configuration
    Show,
}

#[derive(Clone, ValueEnum)]
enum ModelArg {
    WhisperTiny,
    WhisperTinyEn,
    WhisperBase,
    WhisperBaseEn,
    WhisperSmall,
    WhisperSmallEn,
    WhisperMedium,
    WhisperMediumEn,
    WhisperLargeV3,
    WhisperLargeV3Turbo,
}

impl From<ModelArg> for SpeechModel {
    fn from(arg: ModelArg) -> Self {
        match arg {
            ModelArg::WhisperTiny => SpeechModel::WhisperTiny,
            ModelArg::WhisperTinyEn => SpeechModel::WhisperTinyEn,
            ModelArg::WhisperBase => SpeechModel::WhisperBase,
            ModelArg::WhisperBaseEn => SpeechModel::WhisperBaseEn,
            ModelArg::WhisperSmall => SpeechModel::WhisperSmall,
            ModelArg::WhisperSmallEn => SpeechModel::WhisperSmallEn,
            ModelArg::WhisperMedium => SpeechModel::WhisperMedium,
            ModelArg::WhisperMediumEn => SpeechModel::WhisperMediumEn,
            ModelArg::WhisperLargeV3 => SpeechModel::WhisperLargeV3,
            ModelArg::WhisperLargeV3Turbo => SpeechModel::WhisperLargeV3Turbo,
        }
    }
}

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::registry()
        .with(fmt::layer())
        .with(EnvFilter::from_default_env())
        .init();

    let cli = Cli::parse();

    match cli.command {
        Commands::Start => {
            cmd_start().await?;
        }
        Commands::Stop => {
            cmd_stop().await?;
        }
        Commands::Status => {
            cmd_status().await?;
        }
        Commands::Toggle => {
            cmd_toggle().await?;
        }
        Commands::Config { action } => match action {
            ConfigAction::Path => {
                let path = Config::config_path()?;
                println!("{}", path.display());
            }
            ConfigAction::Init { model, force } => {
                let path = Config::config_path()?;
                if path.exists() && !force {
                    eprintln!("Config file already exists: {}", path.display());
                    eprintln!("Use --force to overwrite");
                    std::process::exit(1);
                }

                let mut config = Config::default();
                config.model.model = model.into();
                config.save()?;

                println!("Created config file: {}", path.display());
                println!();
                println!("Model: {:?}", config.model.model);
                println!("Languages: {:?}", config.model.languages);
            }
            ConfigAction::Show => {
                let path = Config::config_path()?;
                if !path.exists() {
                    println!("No config file found at: {}", path.display());
                    println!("Using defaults. Run 'vcm config init' to create one.");
                    println!();
                }

                let config = Config::load()?;
                println!("Config path: {}", path.display());
                println!();
                println!("[model]");
                println!("model = {:?}", config.model.model);
                println!("languages = {:?}", config.model.languages);
                println!();
                println!("[latency]");
                println!("mode = {:?}", config.latency.mode);
                println!("min_chunk_seconds = {}", config.latency.min_chunk_seconds);
            }
        },
    }

    Ok(())
}

async fn cmd_start() -> Result<()> {
    let sock_path = socket_path()?;

    if client::is_daemon_running(&sock_path).await {
        // Read PID from file
        let pid_path = voice_controllm_daemon::socket::pid_path()?;
        let pid = std::fs::read_to_string(&pid_path)
            .unwrap_or_else(|_| "unknown".to_string());
        println!("Daemon already running (PID: {})", pid.trim());
        return Ok(());
    }

    println!("Starting daemon... (spawning not yet implemented)");
    // Task 7 will implement actual spawning
    Ok(())
}

async fn cmd_stop() -> Result<()> {
    let sock_path = socket_path()?;

    if !client::is_daemon_running(&sock_path).await {
        println!("Daemon not running");
        return Ok(());
    }

    let mut client = client::connect(&sock_path).await?;
    client.shutdown(Empty {}).await
        .context("Failed to send shutdown")?;

    println!("Daemon stopped");
    Ok(())
}

async fn cmd_status() -> Result<()> {
    let sock_path = socket_path()?;

    if !sock_path.exists() {
        println!("Daemon not running");
        return Ok(());
    }

    let mut client = match client::connect(&sock_path).await {
        Ok(c) => c,
        Err(_) => {
            println!("Daemon not running");
            return Ok(());
        }
    };

    let response = client.get_status(Empty {}).await
        .context("Failed to get status")?;

    let status = response.into_inner();
    match status.status {
        Some(StatusVariant::Healthy(h)) => {
            let state = voice_controllm_proto::State::try_from(h.state)
                .unwrap_or(voice_controllm_proto::State::StateStopped);
            match state {
                voice_controllm_proto::State::StateStopped => println!("Stopped"),
                voice_controllm_proto::State::StateListening => println!("Listening"),
                voice_controllm_proto::State::StatePaused => println!("Paused"),
            }
        }
        Some(StatusVariant::Error(e)) => {
            println!("Error: {}", e.message);
        }
        None => {
            println!("Unknown status");
        }
    }

    Ok(())
}

async fn cmd_toggle() -> Result<()> {
    let sock_path = socket_path()?;

    if !client::is_daemon_running(&sock_path).await {
        println!("Daemon not running");
        return Ok(());
    }

    let mut client = client::connect(&sock_path).await?;

    // Get current status
    let response = client.get_status(Empty {}).await
        .context("Failed to get status")?;

    let status = response.into_inner();
    match status.status {
        Some(StatusVariant::Healthy(h)) => {
            let state = voice_controllm_proto::State::try_from(h.state)
                .unwrap_or(voice_controllm_proto::State::StateStopped);
            match state {
                voice_controllm_proto::State::StateListening => {
                    client.stop_listening(Empty {}).await
                        .context("Failed to stop listening")?;
                    println!("Paused");
                }
                voice_controllm_proto::State::StatePaused => {
                    client.start_listening(Empty {}).await
                        .context("Failed to start listening")?;
                    println!("Listening");
                }
                voice_controllm_proto::State::StateStopped => {
                    println!("Daemon is stopped");
                }
            }
        }
        Some(StatusVariant::Error(e)) => {
            println!("Error: {}", e.message);
        }
        None => {
            println!("Unknown status");
        }
    }

    Ok(())
}
```

**Step 4: Build to verify**

Run: `cargo build -p vcm`

Expected: Build succeeds

**Step 5: Commit**

```bash
git add cli/
git commit -m "feat(cli): add gRPC client and status/toggle/stop commands"
```

---

## Task 7: Add Daemon Spawning

**Files:**
- Modify: `cli/src/main.rs`

**Step 1: Implement daemon spawning in cmd_start**

Replace the `cmd_start` function in `cli/src/main.rs`:

```rust
use std::time::Duration;

async fn cmd_start() -> Result<()> {
    let sock_path = socket_path()?;

    if client::is_daemon_running(&sock_path).await {
        let pid_path = voice_controllm_daemon::socket::pid_path()?;
        let pid = std::fs::read_to_string(&pid_path)
            .unwrap_or_else(|_| "unknown".to_string());
        println!("Daemon already running (PID: {})", pid.trim());
        return Ok(());
    }

    // Spawn daemon as detached process
    let daemon_path = std::env::current_exe()?
        .parent()
        .context("No parent directory")?
        .join("voice-controllm-daemon");

    if !daemon_path.exists() {
        anyhow::bail!("Daemon binary not found at: {}", daemon_path.display());
    }

    // Spawn detached
    std::process::Command::new(&daemon_path)
        .stdin(std::process::Stdio::null())
        .stdout(std::process::Stdio::null())
        .stderr(std::process::Stdio::null())
        .spawn()
        .context("Failed to spawn daemon")?;

    // Wait for socket to appear (up to 2 seconds)
    for _ in 0..20 {
        tokio::time::sleep(Duration::from_millis(100)).await;
        if client::is_daemon_running(&sock_path).await {
            let pid_path = voice_controllm_daemon::socket::pid_path()?;
            let pid = std::fs::read_to_string(&pid_path)
                .unwrap_or_else(|_| "unknown".to_string());
            println!("Daemon started (PID: {})", pid.trim());
            return Ok(());
        }
    }

    anyhow::bail!("Daemon failed to start within 2 seconds");
}
```

**Step 2: Add Duration import**

Ensure `use std::time::Duration;` is at the top of `cli/src/main.rs`.

**Step 3: Build to verify**

Run: `cargo build`

Expected: Build succeeds

**Step 4: Manual test**

```bash
# In one terminal, start daemon directly to verify it works
cargo run -p voice-controllm-daemon

# In another terminal
cargo run -p vcm -- status
# Expected: "Paused"

cargo run -p vcm -- toggle
# Expected: "Listening"

cargo run -p vcm -- stop
# Expected: "Daemon stopped"
```

**Step 5: Commit**

```bash
git add cli/src/main.rs
git commit -m "feat(cli): add daemon spawning for vcm start"
```

---

## Task 8: Add Graceful Shutdown

**Files:**
- Modify: `daemon/src/daemon.rs`
- Modify: `daemon/src/controller.rs`
- Modify: `daemon/src/server.rs`

**Step 1: Add shutdown channel to controller**

Modify `daemon/src/controller.rs` to add shutdown support:

```rust
//! Controller manages daemon state and coordinates components.

use std::sync::Arc;
use tokio::sync::{broadcast, RwLock, oneshot};
use voice_controllm_proto::{Event, State, StateChange};

/// Controller state.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ControllerState {
    Stopped,
    Listening,
    Paused,
}

impl From<ControllerState> for State {
    fn from(state: ControllerState) -> Self {
        match state {
            ControllerState::Stopped => State::StateStopped,
            ControllerState::Listening => State::StateListening,
            ControllerState::Paused => State::StatePaused,
        }
    }
}

/// Event sender type.
pub type EventSender = broadcast::Sender<Event>;

/// Controller for daemon state management.
pub struct Controller {
    state: Arc<RwLock<ControllerState>>,
    event_tx: EventSender,
    shutdown_tx: Arc<RwLock<Option<oneshot::Sender<()>>>>,
}

impl Controller {
    /// Create a new controller with a shutdown channel.
    pub fn new(event_tx: EventSender, shutdown_tx: oneshot::Sender<()>) -> Self {
        Self {
            state: Arc::new(RwLock::new(ControllerState::Paused)),
            event_tx,
            shutdown_tx: Arc::new(RwLock::new(Some(shutdown_tx))),
        }
    }

    /// Get the current state.
    pub async fn state(&self) -> ControllerState {
        *self.state.read().await
    }

    /// Start listening.
    pub async fn start_listening(&self) -> Result<(), String> {
        let mut state = self.state.write().await;
        match *state {
            ControllerState::Paused => {
                *state = ControllerState::Listening;
                self.broadcast_state_change(ControllerState::Listening);
                Ok(())
            }
            ControllerState::Listening => Ok(()),
            ControllerState::Stopped => Err("Daemon is stopped".to_string()),
        }
    }

    /// Stop listening (pause).
    pub async fn stop_listening(&self) -> Result<(), String> {
        let mut state = self.state.write().await;
        match *state {
            ControllerState::Listening => {
                *state = ControllerState::Paused;
                self.broadcast_state_change(ControllerState::Paused);
                Ok(())
            }
            ControllerState::Paused => Ok(()),
            ControllerState::Stopped => Err("Daemon is stopped".to_string()),
        }
    }

    /// Trigger shutdown.
    pub async fn shutdown(&self) {
        let mut state = self.state.write().await;
        *state = ControllerState::Stopped;
        self.broadcast_state_change(ControllerState::Stopped);

        // Send shutdown signal
        if let Some(tx) = self.shutdown_tx.write().await.take() {
            let _ = tx.send(());
        }
    }

    /// Broadcast a state change event.
    fn broadcast_state_change(&self, new_state: ControllerState) {
        let event = Event {
            event: Some(voice_controllm_proto::event::Event::StateChange(
                StateChange {
                    status: Some(voice_controllm_proto::state_change::Status::NewState(
                        State::from(new_state).into(),
                    )),
                },
            )),
        };
        let _ = self.event_tx.send(event);
    }

    /// Get the event sender for creating subscribers.
    pub fn event_sender(&self) -> EventSender {
        self.event_tx.clone()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn create_controller() -> (Controller, oneshot::Receiver<()>) {
        let (event_tx, _) = broadcast::channel(16);
        let (shutdown_tx, shutdown_rx) = oneshot::channel();
        (Controller::new(event_tx, shutdown_tx), shutdown_rx)
    }

    #[tokio::test]
    async fn test_initial_state_is_paused() {
        let (controller, _) = create_controller();
        assert_eq!(controller.state().await, ControllerState::Paused);
    }

    #[tokio::test]
    async fn test_start_listening_from_paused() {
        let (controller, _) = create_controller();
        controller.start_listening().await.unwrap();
        assert_eq!(controller.state().await, ControllerState::Listening);
    }

    #[tokio::test]
    async fn test_stop_listening_from_listening() {
        let (controller, _) = create_controller();
        controller.start_listening().await.unwrap();
        controller.stop_listening().await.unwrap();
        assert_eq!(controller.state().await, ControllerState::Paused);
    }

    #[tokio::test]
    async fn test_shutdown_sends_signal() {
        let (controller, shutdown_rx) = create_controller();
        controller.shutdown().await;
        assert_eq!(controller.state().await, ControllerState::Stopped);
        // Receiver should complete (not hang)
        assert!(shutdown_rx.await.is_ok());
    }

    #[tokio::test]
    async fn test_start_listening_broadcasts_event() {
        let (event_tx, mut event_rx) = broadcast::channel(16);
        let (shutdown_tx, _) = oneshot::channel();
        let controller = Controller::new(event_tx, shutdown_tx);

        controller.start_listening().await.unwrap();

        let event = event_rx.recv().await.unwrap();
        match event.event {
            Some(voice_controllm_proto::event::Event::StateChange(change)) => {
                match change.status {
                    Some(voice_controllm_proto::state_change::Status::NewState(state)) => {
                        assert_eq!(state, State::StateListening.into());
                    }
                    _ => panic!("Expected NewState"),
                }
            }
            _ => panic!("Expected StateChange event"),
        }
    }
}
```

**Step 2: Update server to call shutdown**

Modify the `shutdown` method in `daemon/src/server.rs`:

```rust
    async fn shutdown(&self, _request: Request<Empty>) -> Result<Response<Empty>, Status> {
        self.controller.shutdown().await;
        Ok(Response::new(Empty {}))
    }
```

**Step 3: Update daemon runner to use shutdown signal**

Modify `daemon/src/daemon.rs`:

```rust
//! Daemon runner that orchestrates all components.

use std::sync::Arc;
use anyhow::{Context, Result};
use tokio::sync::{broadcast, oneshot};
use tonic::transport::Server;
use tracing::info;

use crate::controller::Controller;
use crate::server::VoiceControllmService;
use crate::socket::{cleanup_socket, create_listener, pid_path, socket_path};

/// Run the daemon.
pub async fn run() -> Result<()> {
    // Get paths
    let sock_path = socket_path()?;
    let pid_file = pid_path()?;

    // Write PID file
    let pid = std::process::id();
    std::fs::write(&pid_file, pid.to_string())
        .context("Failed to write PID file")?;
    info!(pid = pid, path = %pid_file.display(), "Wrote PID file");

    // Create Unix socket listener
    let listener = create_listener(&sock_path)?;
    info!(path = %sock_path.display(), "Listening on Unix socket");

    // Create shutdown channel
    let (shutdown_tx, shutdown_rx) = oneshot::channel();

    // Create controller with event channel
    let (event_tx, _) = broadcast::channel(256);
    let controller = Arc::new(Controller::new(event_tx, shutdown_tx));

    // Create gRPC service
    let service = VoiceControllmService::new(controller.clone());

    // Convert UnixListener to stream
    let incoming = async_stream::stream! {
        loop {
            match listener.accept().await {
                Ok((stream, _)) => yield Ok::<_, std::io::Error>(stream),
                Err(e) => {
                    tracing::error!(error = %e, "Accept error");
                }
            }
        }
    };

    // Run server with graceful shutdown
    info!("Daemon started");
    let server = Server::builder()
        .add_service(service.into_server())
        .serve_with_incoming_shutdown(incoming, async {
            let _ = shutdown_rx.await;
            info!("Shutdown signal received");
        });

    let result = server.await;

    // Cleanup
    cleanup_socket(&sock_path);
    let _ = std::fs::remove_file(&pid_file);
    info!("Daemon stopped");

    result.context("Server error")
}
```

**Step 4: Run tests**

Run: `cargo test -p voice-controllm-daemon controller`

Expected: All 5 tests pass

**Step 5: Build and manual test**

```bash
cargo build

# Terminal 1: Start daemon
cargo run -p voice-controllm-daemon

# Terminal 2: Stop it
cargo run -p vcm -- stop
# Daemon in terminal 1 should exit cleanly
```

**Step 6: Commit**

```bash
git add daemon/src/controller.rs daemon/src/server.rs daemon/src/daemon.rs
git commit -m "feat(daemon): add graceful shutdown"
```

---

## Task 9: Update Project Roadmap

**Files:**
- Modify: `docs/plans/project-roadmap.md`

**Step 1: Update Phase 2 status**

Update the Phase 2 section in `docs/plans/project-roadmap.md`:

```markdown
### Phase 2: IPC & CLI ✅ Complete

Daemon/CLI communication and process management.

| Component | Status | Description |
|-----------|--------|-------------|
| gRPC definitions | ✅ Done | proto/ with service definitions |
| Daemon server | ✅ Done | tonic gRPC server on Unix socket |
| CLI client | ✅ Done | CLI connects to daemon via gRPC |
| `vcm start` | ✅ Done | Spawn daemon as background process |
| `vcm stop` | ✅ Done | Send shutdown signal to daemon |
| `vcm status` | ✅ Done | Query daemon state |
| `vcm toggle` | ✅ Done | Quick on/off for listening |
| `vcm test-mic` | ⬜ Deferred | Test microphone input (Phase 4) |
| `vcm transcribe <file>` | ⬜ Deferred | Transcribe audio file (Phase 4) |
```

Also update "Current Focus" section:

```markdown
## Current Focus

**Phase 3: Menu Bar App** - Building Tauri system tray application.

Phase 2 complete: gRPC IPC between daemon and CLI with process management.
```

**Step 2: Commit**

```bash
git add docs/plans/project-roadmap.md
git commit -m "docs: mark Phase 2 as complete"
```

---

## Summary

| Task | Description | Commits |
|------|-------------|---------|
| 1 | Create proto crate with gRPC definitions | 1 |
| 2 | Add daemon gRPC server stub | 1 |
| 3 | Add controller with state machine | 1 |
| 4 | Add Unix socket utilities | 1 |
| 5 | Create daemon runner | 1 |
| 6 | Add CLI gRPC client | 1 |
| 7 | Add daemon spawning | 1 |
| 8 | Add graceful shutdown | 1 |
| 9 | Update roadmap | 1 |

**Total: 9 tasks, 9 commits**
